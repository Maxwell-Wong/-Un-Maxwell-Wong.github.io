# P3397 地毯

## 题目背景

此题约为NOIP提高组Day2T1难度。

## 题目描述

在 n×n*n*×*n* 的格子上有 m*m* 个地毯。

给出这些地毯的信息，问每个点被多少个地毯覆盖。

## 输入格式

第一行，两个正整数 n,m*n*,*m*。意义如题所述。

接下来 m*m* 行，每行两个坐标 (x1,y1)(*x*1,*y*1) 和 (x2,y2)(*x*2,*y*2)，代表一块地毯，左上角是 (x1,y1)(*x*1,*y*1)，右下角是 (x2,y2)(*x*2,*y*2)。

## 输出格式

输出 n*n* 行，每行 n*n* 个正整数。

第 i*i* 行第 j*j* 列的正整数表示 (i,j)(*i*,*j*) 这个格子被多少个地毯覆盖。

## 输入输出样例

**输入 #1**复制

```
5 3
2 2 3 3
3 3 5 5
1 2 1 4
```

**输出 #1**复制

```
0 1 1 1 0
0 1 1 0 0
0 1 2 1 1
0 0 1 1 1
0 0 1 1 1
```

## 说明/提示

### 数据范围

对于 20%20% 的数据，有 n≤50*n*≤50，m≤100*m*≤100。

对于 100%100% 的数据，有 n,m≤1000*n*,*m*≤1000。

### **解析：**

**这题运用了差分的思想**

差分：将要覆盖的区域的头一列打上记号（++），最后一列再往右一列也打上记号（--），最后再从左往右遍历，每次都加上当前位置的值，并且保留着这个sum值，每往后遍历时，每个遍历到的格子都应该是这个sum值，直到最后一列与其抵消掉变成0。

```
假设我们现在要给[2,5]这个区间加一。原来的序列是：

0 0 0 0 0 0 0 0

这时候我们在2上面打 +1 标记， 6 上面打 -1 标记。那么现在的序列是：

0 +1 0 0 0 -1 0

有什么用呢？从左往右扫描这个数组，记录当前经过的标签之和。这个和就是对应那个数的答案。

这样，对于每个区间加操作，只需要O(1) 的时间打上标记。

最后扫描输出即可。

现在把问题拓展到二维。假设我们要覆盖[(2,2),(5,5)] ，那么标记便可以这样打：
0 0 0 0 0 0
0 +1 0 0 0 -1  从左往右遍历，正好第2、3、4、5列都是1，第6列1-1=0正好抵消掉
0 +1 0 0 0 -1
0 +1 0 0 0 -1
0 +1 0 0 0 -1
0 0 0 0 0 0
注：+1指的是对应位置的值++，-1则是--
标记的打法：假设坐标是(x1，y1),(x2,y2)，那么便固定住y1这一列和y2+1这一列，从上往下遍历x1～x2，y1这一列对应的数组++，y2这一列对应的数组--。

```

```c++
#include<iostream>
using namespace std;
int n,m;
int sum;
int xx1,yy1,xx2,yy2;
int flag[10001][10001];
int real[10001][10001];
int main()
{
    cin>>n>>m;
    while(m--)
    {
        cin>>xx1>>yy1>>xx2>>yy2;
        for(int i=xx1;i<=xx2;i++)
        {
            flag[i][yy1]++;
            flag[i][yy2+1]--;
        }
    }
    for(int i=1;i<=n+1;i++)
    for(int j=1;j<=n+1;j++)
    {
        sum+=flag[i][j];
        real[i][j]=sum;
    }
    for(int i=1;i<=n;i++){
    for(int j=1;j<=n;j++){
    cout<<real[i][j]<<" ";
    }
    cout<<endl;
    }
}

```

