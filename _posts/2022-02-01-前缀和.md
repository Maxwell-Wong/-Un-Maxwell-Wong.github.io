# P1115 最大子段和

## 题目描述

给出一个长度为 n*n* 的序列 a*a*，选出其中连续且非空的一段使得这段和最大。

## 输入格式

第一行是一个整数，表示序列的长度 n*n*。

第二行有 n*n* 个整数，第 i*i* 个整数表示序列的第 i*i* 个数字 ai*a**i*。

## 输出格式

输出一行一个整数表示答案。

## 输入输出样例

**输入 #1**复制

```
7
2 -4 3 -1 2 -4 3
```

**输出 #1**复制

```
4
```

## 说明/提示

#### 样例 1 解释

选取 [3,5][3,5] 子段 {3,−1,2}{3,−1,2}，其和为 44。

#### 数据规模与约定

- 对于 40%40% 的数据，保证 n≤2×103*n*≤2×103。
- 对于 100%100% 的数据，保证 1≤n≤2×1051≤*n*≤2×105，−104≤ai≤104−104≤*a**i*≤104。

```c++
#include<iostream>
using namespace std;
int n,num;
int maxn=-9999999;
int sum[100001];//存放前缀和
int minn;
int a[200001],b[200001];//a存放当前输入的数，b存放从1～i这个区间里的最大前缀和（可以是子区间）
int main()
{
    cin>>n;
    for(int i=1;i<=n;i++)
    {
        cin>>a[i];
        sum[i]=sum[i-1]+a[i];
    }
    b[1]=a[1];//b[1]是从1～1的最大子段和，因此赋初值a[1]就可以了
    minn=min(0,sum[1]);//这里是关键，如果是负数，则赋值给minn，如果不是则minn=0
    for(int i=2;i<=n;i++)//从2开始遍历
    {
        b[i]=sum[i]-minn;//减去负数相当于加上一个正数
        minn=min(minn,sum[i]);//这里的minn不是负数就是0
    }
    for(int i=1;i<=n;i++)
    maxn=max(maxn,b[i]);//
    
    cout<<maxn;
    
}
2，-2，1，0，sum[5]=2
  minn=-2
2,1,-4,4,9
2,3,-1
```

